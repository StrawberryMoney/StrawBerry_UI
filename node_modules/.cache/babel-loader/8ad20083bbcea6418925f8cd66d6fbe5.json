{"ast":null,"code":"import { BigNumber, ethers } from 'ethers';\nimport { useCallback, useMemo } from 'react';\nimport { useHasPendingApproval, useTransactionAdder } from '../state/transactions/hooks';\nimport useAllowance from './useAllowance';\nimport { AVAX_TICKER, TOMB_TICKER, TSHARE_TICKER, ZAPPER_ROUTER_ADDR } from '../utils/constants';\nimport useTombFinance from './useTombFinance';\nconst APPROVE_AMOUNT = ethers.constants.MaxUint256;\nconst APPROVE_BASE_AMOUNT = BigNumber.from('1000000000000000000000000');\nexport let ApprovalState; // returns a variable indicating the state of the approval and a function which approves if necessary or early returns\n\n(function (ApprovalState) {\n  ApprovalState[ApprovalState[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  ApprovalState[ApprovalState[\"NOT_APPROVED\"] = 1] = \"NOT_APPROVED\";\n  ApprovalState[ApprovalState[\"PENDING\"] = 2] = \"PENDING\";\n  ApprovalState[ApprovalState[\"APPROVED\"] = 3] = \"APPROVED\";\n})(ApprovalState || (ApprovalState = {}));\n\nfunction useApproveZapper(zappingToken) {\n  const tombFinance = useTombFinance();\n  let token;\n  if (zappingToken === AVAX_TICKER) token = tombFinance.AVAX;else if (zappingToken === TOMB_TICKER) token = tombFinance.TOMB;else if (zappingToken === TSHARE_TICKER) token = tombFinance.TSHARE;\n  const pendingApproval = useHasPendingApproval(token.address, ZAPPER_ROUTER_ADDR);\n  const currentAllowance = useAllowance(token, ZAPPER_ROUTER_ADDR, pendingApproval); // check the current approval status\n\n  const approvalState = useMemo(() => {\n    // we might not have enough data to know whether or not we need to approve\n    if (token === tombFinance.AVAX) return ApprovalState.APPROVED;\n    if (!currentAllowance) return ApprovalState.UNKNOWN; // amountToApprove will be defined if currentAllowance is\n\n    return currentAllowance.lt(APPROVE_BASE_AMOUNT) ? pendingApproval ? ApprovalState.PENDING : ApprovalState.NOT_APPROVED : ApprovalState.APPROVED;\n  }, [currentAllowance, pendingApproval, token, tombFinance]);\n  const addTransaction = useTransactionAdder();\n  const approve = useCallback(async () => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n\n    const response = await token.approve(ZAPPER_ROUTER_ADDR, APPROVE_AMOUNT);\n    addTransaction(response, {\n      summary: `Approve ${token.symbol}`,\n      approval: {\n        tokenAddress: token.address,\n        spender: ZAPPER_ROUTER_ADDR\n      }\n    });\n  }, [approvalState, token, addTransaction]);\n  return [approvalState, approve];\n}\n\nexport default useApproveZapper;","map":{"version":3,"sources":["C:/Users/ali_9/Desktop/StrawBerry_UI/src/hooks/useApproveZapper.ts"],"names":["BigNumber","ethers","useCallback","useMemo","useHasPendingApproval","useTransactionAdder","useAllowance","AVAX_TICKER","TOMB_TICKER","TSHARE_TICKER","ZAPPER_ROUTER_ADDR","useTombFinance","APPROVE_AMOUNT","constants","MaxUint256","APPROVE_BASE_AMOUNT","from","ApprovalState","useApproveZapper","zappingToken","tombFinance","token","AVAX","TOMB","TSHARE","pendingApproval","address","currentAllowance","approvalState","APPROVED","UNKNOWN","lt","PENDING","NOT_APPROVED","addTransaction","approve","console","error","response","summary","symbol","approval","tokenAddress","spender"],"mappings":"AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,QAAlC;AACA,SAASC,WAAT,EAAsBC,OAAtB,QAAqC,OAArC;AACA,SAASC,qBAAT,EAAgCC,mBAAhC,QAA2D,6BAA3D;AACA,OAAOC,YAAP,MAAyB,gBAAzB;AAEA,SAASC,WAAT,EAAsBC,WAAtB,EAAmCC,aAAnC,EAAkDC,kBAAlD,QAA4E,oBAA5E;AACA,OAAOC,cAAP,MAA2B,kBAA3B;AAEA,MAAMC,cAAc,GAAGX,MAAM,CAACY,SAAP,CAAiBC,UAAxC;AACA,MAAMC,mBAAmB,GAAGf,SAAS,CAACgB,IAAV,CAAe,2BAAf,CAA5B;AAEA,WAAYC,aAAZ,C,CAOA;;WAPYA,a;AAAAA,EAAAA,a,CAAAA,a;AAAAA,EAAAA,a,CAAAA,a;AAAAA,EAAAA,a,CAAAA,a;AAAAA,EAAAA,a,CAAAA,a;GAAAA,a,KAAAA,a;;AAQZ,SAASC,gBAAT,CAA0BC,YAA1B,EAAsF;AACpF,QAAMC,WAAW,GAAGT,cAAc,EAAlC;AACA,MAAIU,KAAJ;AACA,MAAIF,YAAY,KAAKZ,WAArB,EAAkCc,KAAK,GAAGD,WAAW,CAACE,IAApB,CAAlC,KACK,IAAIH,YAAY,KAAKX,WAArB,EAAkCa,KAAK,GAAGD,WAAW,CAACG,IAApB,CAAlC,KACA,IAAIJ,YAAY,KAAKV,aAArB,EAAoCY,KAAK,GAAGD,WAAW,CAACI,MAApB;AACzC,QAAMC,eAAe,GAAGrB,qBAAqB,CAACiB,KAAK,CAACK,OAAP,EAAgBhB,kBAAhB,CAA7C;AACA,QAAMiB,gBAAgB,GAAGrB,YAAY,CAACe,KAAD,EAAQX,kBAAR,EAA4Be,eAA5B,CAArC,CAPoF,CASpF;;AACA,QAAMG,aAA4B,GAAGzB,OAAO,CAAC,MAAM;AACjD;AACA,QAAIkB,KAAK,KAAKD,WAAW,CAACE,IAA1B,EAAgC,OAAOL,aAAa,CAACY,QAArB;AAChC,QAAI,CAACF,gBAAL,EAAuB,OAAOV,aAAa,CAACa,OAArB,CAH0B,CAKjD;;AACA,WAAOH,gBAAgB,CAACI,EAAjB,CAAoBhB,mBAApB,IACHU,eAAe,GACbR,aAAa,CAACe,OADD,GAEbf,aAAa,CAACgB,YAHb,GAIHhB,aAAa,CAACY,QAJlB;AAKD,GAX2C,EAWzC,CAACF,gBAAD,EAAmBF,eAAnB,EAAoCJ,KAApC,EAA2CD,WAA3C,CAXyC,CAA5C;AAaA,QAAMc,cAAc,GAAG7B,mBAAmB,EAA1C;AAEA,QAAM8B,OAAO,GAAGjC,WAAW,CAAC,YAA2B;AACrD,QAAI0B,aAAa,KAAKX,aAAa,CAACgB,YAApC,EAAkD;AAChDG,MAAAA,OAAO,CAACC,KAAR,CAAc,kCAAd;AACA;AACD;;AAED,UAAMC,QAAQ,GAAG,MAAMjB,KAAK,CAACc,OAAN,CAAczB,kBAAd,EAAkCE,cAAlC,CAAvB;AACAsB,IAAAA,cAAc,CAACI,QAAD,EAAW;AACvBC,MAAAA,OAAO,EAAG,WAAUlB,KAAK,CAACmB,MAAO,EADV;AAEvBC,MAAAA,QAAQ,EAAE;AACRC,QAAAA,YAAY,EAAErB,KAAK,CAACK,OADZ;AAERiB,QAAAA,OAAO,EAAEjC;AAFD;AAFa,KAAX,CAAd;AAOD,GAd0B,EAcxB,CAACkB,aAAD,EAAgBP,KAAhB,EAAuBa,cAAvB,CAdwB,CAA3B;AAgBA,SAAO,CAACN,aAAD,EAAgBO,OAAhB,CAAP;AACD;;AAED,eAAejB,gBAAf","sourcesContent":["import { BigNumber, ethers } from 'ethers';\nimport { useCallback, useMemo } from 'react';\nimport { useHasPendingApproval, useTransactionAdder } from '../state/transactions/hooks';\nimport useAllowance from './useAllowance';\nimport ERC20 from '../tomb-finance/ERC20';\nimport { AVAX_TICKER, TOMB_TICKER, TSHARE_TICKER, ZAPPER_ROUTER_ADDR } from '../utils/constants';\nimport useTombFinance from './useTombFinance';\n\nconst APPROVE_AMOUNT = ethers.constants.MaxUint256;\nconst APPROVE_BASE_AMOUNT = BigNumber.from('1000000000000000000000000');\n\nexport enum ApprovalState {\n  UNKNOWN,\n  NOT_APPROVED,\n  PENDING,\n  APPROVED,\n}\n\n// returns a variable indicating the state of the approval and a function which approves if necessary or early returns\nfunction useApproveZapper(zappingToken: string): [ApprovalState, () => Promise<void>] {\n  const tombFinance = useTombFinance();\n  let token: ERC20;\n  if (zappingToken === AVAX_TICKER) token = tombFinance.AVAX;\n  else if (zappingToken === TOMB_TICKER) token = tombFinance.TOMB;\n  else if (zappingToken === TSHARE_TICKER) token = tombFinance.TSHARE;\n  const pendingApproval = useHasPendingApproval(token.address, ZAPPER_ROUTER_ADDR);\n  const currentAllowance = useAllowance(token, ZAPPER_ROUTER_ADDR, pendingApproval);\n\n  // check the current approval status\n  const approvalState: ApprovalState = useMemo(() => {\n    // we might not have enough data to know whether or not we need to approve\n    if (token === tombFinance.AVAX) return ApprovalState.APPROVED;\n    if (!currentAllowance) return ApprovalState.UNKNOWN;\n\n    // amountToApprove will be defined if currentAllowance is\n    return currentAllowance.lt(APPROVE_BASE_AMOUNT)\n      ? pendingApproval\n        ? ApprovalState.PENDING\n        : ApprovalState.NOT_APPROVED\n      : ApprovalState.APPROVED;\n  }, [currentAllowance, pendingApproval, token, tombFinance]);\n\n  const addTransaction = useTransactionAdder();\n\n  const approve = useCallback(async (): Promise<void> => {\n    if (approvalState !== ApprovalState.NOT_APPROVED) {\n      console.error('approve was called unnecessarily');\n      return;\n    }\n\n    const response = await token.approve(ZAPPER_ROUTER_ADDR, APPROVE_AMOUNT);\n    addTransaction(response, {\n      summary: `Approve ${token.symbol}`,\n      approval: {\n        tokenAddress: token.address,\n        spender: ZAPPER_ROUTER_ADDR,\n      },\n    });\n  }, [approvalState, token, addTransaction]);\n\n  return [approvalState, approve];\n}\n\nexport default useApproveZapper;\n"]},"metadata":{},"sourceType":"module"}